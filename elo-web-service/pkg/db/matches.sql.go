// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (date, game_id, google_sheet_row)
VALUES ($1, $2, $3)
RETURNING id, date, game_id, google_sheet_row
`

type CreateMatchParams struct {
	Date           pgtype.Timestamptz `json:"date"`
	GameID         int32              `json:"game_id"`
	GoogleSheetRow pgtype.Int4        `json:"google_sheet_row"`
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch, arg.Date, arg.GameID, arg.GoogleSheetRow)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.GameID,
		&i.GoogleSheetRow,
	)
	return i, err
}

const listMatchResults = `-- name: ListMatchResults :many
SELECT
    m.id AS match_id,
    m.date,
    g.name AS game_name,
    p.id AS player_id,
    p.name AS player_name,
    s.score
FROM match_scores s
JOIN players p ON p.id = s.player_id
JOIN matches m ON m.id = s.match_id
JOIN games g ON g.id = m.game_id
WHERE m.id = $1
ORDER BY s.score DESC
`

type ListMatchResultsRow struct {
	MatchID    int32              `json:"match_id"`
	Date       pgtype.Timestamptz `json:"date"`
	GameName   string             `json:"game_name"`
	PlayerID   int32              `json:"player_id"`
	PlayerName string             `json:"player_name"`
	Score      float64            `json:"score"`
}

func (q *Queries) ListMatchResults(ctx context.Context, id int32) ([]ListMatchResultsRow, error) {
	rows, err := q.db.Query(ctx, listMatchResults, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMatchResultsRow{}
	for rows.Next() {
		var i ListMatchResultsRow
		if err := rows.Scan(
			&i.MatchID,
			&i.Date,
			&i.GameName,
			&i.PlayerID,
			&i.PlayerName,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMatchScore = `-- name: UpsertMatchScore :exec
INSERT INTO match_scores (match_id, player_id, score)
VALUES ($1, $2, $3)
ON CONFLICT (match_id, player_id)
DO UPDATE SET score = EXCLUDED.score
`

type UpsertMatchScoreParams struct {
	MatchID  int32   `json:"match_id"`
	PlayerID int32   `json:"player_id"`
	Score    float64 `json:"score"`
}

func (q *Queries) UpsertMatchScore(ctx context.Context, arg UpsertMatchScoreParams) error {
	_, err := q.db.Exec(ctx, upsertMatchScore, arg.MatchID, arg.PlayerID, arg.Score)
	return err
}
